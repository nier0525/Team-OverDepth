# Team-OverDepth
--------------------------------------------
팀명 : OverDepth  
게임명 : OverDepth  
개발 기간 : 2020.03.01 - 2020.12.03  
개발 환경 : Unity3D / Unity C# / C++ / Github Desktop / Trello  
개발 인원 : 11명 ( 기획 3 / 프로그래밍 4 / 그래픽 4 )  
  
```  
최대 2인까지 협동 가능한 3D 멀티 액션 게임으로 OverDepth 만의 특수한 기믹과 강력한 몬스터들을 협력하여 공략해 나가는 게임입니다.  
G-Star 2020 출품, 교내 경진대회 출품 및 최우수상 수상, GGC ( Global Game Challenge 2020 ) 금상 수상 등의 성과를 내었습니다.  
```  
  
+ 담당 업무 : 서버 / 클라이언트 프로그래머  
  + 서버 세부 업무 : 라이브러리 설계, MYSQL 연동, 본 게임과의 연동 등 전체적인 모든 서버 시스템  
  + 클라이언트 세부 업무 : 게임 UI, 옵션, 타이틀 화면과 같은 게임 시스템 기능 및 플레이어 서버 동기화와 보간 기능  
  
이 문서에서는 클라이언트 업무에 대한 자료를 작성하지 않았습니다.  
  
# 게임 소개
-------------------------------------------  
  
게임 영상 링크 : https://www.youtube.com/watch?v=y0tODYMJPVg  
  
<img src = "https://user-images.githubusercontent.com/63215359/102127979-86a36500-3e90-11eb-8acd-45a96c9f0246.PNG" width="350" height="300">
<img src = "https://user-images.githubusercontent.com/63215359/102128119-bc484e00-3e90-11eb-9ab5-afeb920b8e88.PNG" width="350" height="300">
<img src = "https://user-images.githubusercontent.com/63215359/102128137-c23e2f00-3e90-11eb-8afb-220d5221c968.PNG" width="350" height="300">
  
```  
OverDepth 는 최대 2인 협동이 가능한 3D 멀티 액션 게임 입니다.  
Soul Like 류의 게임 중 대표격인 블러드본, 다크소울과 같은 게임에 영향이 많이 받았습니다.  
  
게임 시작 시 플레이 할 캐릭터를 선택하고 다른 유저와의 매칭을 대기하게 됩니다.  
2인이 서로 매칭이 되었을 경우 게임을 진행할 수 있으며 서로 협동하여 각종 퍼즐과 몬스터를 공략하고,  
최종적으로 마지막 보스를 제거하면 게임을 클리어 할 수 있습니다.  
```  

# 담당 게임 기능
------------------------------------------  
  
+ 서버  
  + 서버 라이브러리  
  + 클라이언트 라이브러리  
  + 플레이어 동기화  
  + 서버-클라이언트 보간  
   
# 서버
-----------------------------------------
## 서버 라이브러리
-----------------------------------------
  
서버 라이브러리는 IOCP 를 기반으로 설계되었으며 DB 는 MYSQL 과 연동하고 있습니다.  
  
### Protocol 
--------------------------------------------------------------  
  
프로토콜은 바이트 연산을 이용하여 그 기능과 역할을 세분화하여 관리하기 용이하도록 구현하였고, 기본적으로 Main, Sub, Protocol 로 나누어 사용하고 있습니다.  
  
Main 의 역할은 그 기능의 큰 틀로 보통 클래스명을 사용하고 합니다. ( MonsterClass, PlayerClass . . . )  
Sub 의 역할은 클래스 내에 어떤 멤버 함수를 사용할 것인가에 대한 기능으로 그 기준은 사용자의 재량에 따릅니다.  
( Attack, Move 또는 몬스터 종류별 함수 등 . . . )  
Protocol 의 역할은 어떤 기능을 사용할 것인지를 선택하는 기능으로 가장 핵심적인 역할을 담당하고 있습니다.  
  
### MYSQL 
--------------------------------------------------------------  
  
MySQL 을 C++ 을 연동하여 DB 를 관리할 수 있도록 구현하였습니다.   
본 게임에서는 유저의 계정 정보 정도만 관리하고 있습니다.  
구현된 기능은 저장하기, 불러오기, 데이터 입력, 쿼리 선택, 데이터베이스 선택 이 있으며, 이후에도 필요 시 추가 할 예정입니다.  
유저의 계정 정보 정도만 관리하고 있고 스테이터스 정보나 인벤토리와 같은 플레이어 정보는 설계되지 않았습니다.  
게임 내에 스테이터스 정보, 인벤토리 기능이 없기 때문입니다.  
하여 위 게임 내에 DB 는 C++ 과 연동하여 관리할 수 있다 정도만 의의로 두고 있습니다.  
차후 클리어 시간을 기준으로 랭킹 정보 정도는 추가하여 관리할 수 있도록 만들고자 합니다.  
  
### CriticalSection_EX
--------------------------------------------------------------  
  
IOCP 가 기반이라 하더라도 다른 클라이언트가 사용 중인 데이터는 중첩으로 사용하게 하면 분명히 문제가 되기 때문에 크리티컬 섹션을 이용하여 이를 방지하였습니다.  
다만, 매번 Enter, Leave 함수를 사용하는 것은 기능이 많아질수록 관리하기 힘들어지고 혹시라도 Leave 기능을 잊고 사용하지 않으면 치명적인 문제를 발생하기 때문에 단 한 번의 호출로 Enter 와 Leave 가 자동으로 되게끔 구현하였습니다.  
  
클래스 생성자, 소멸자의 원리를 이용하여 간단하게 구현하였고 생성자가 호출될 때 Enter, 소멸자가 호출될 때 Leave 하도록 설계하였습니다.  
Lock_Guard 기능과 흡사합니다.  
  
### Listen Socket
--------------------------------------------------------------  
  
Listen 소켓 클래스는 TCP 통신 준비(bind)와 Accept 기능을 담당하고 있습니다.  
Accept 을 통해 서버에게 접속을 시도 중인 클라이언트의 정보를 얻습니다.  
  
### TCP Socket
--------------------------------------------------------------  
  
TCP 소켓 클래스는 순수하게 송신과 수신 기능만을 담당하고 통신에 필요한 멤버 변수를 가지고 있습니다.  
멤버 변수로 가지고 있는 WSAOverLapped_EX 구조체는 전달 받은 클라이언트의 정보를 식별하기 위해서 WSAOverLapped 구조체를 재정의 한 것 입니다.  
이후 Packing 클래스와 Client 클래스는 이 클래스를 상속 받아 사용하게 됩니다.  
  
### Packing
--------------------------------------------------------------  
  
이 클래스는 앞서 만든 TCP 소켓 클래스를 상속 받고 있습니다.
데이터를 자주 주고 받는 것 보단 한 번에 많은 양이라도 최소한으로 주고 받는 것이 좋다고 생각하여 보내고자 하는 데이터를 하나의 Pack 으로 만들어 보내게 됩니다.  
Packing 할 정보는 Pack 전체 크기, 프로토콜, 데이터의 자료형 크기, 데이터 입니다.  
이 클래스에서는 Pack 을 만들어주고, 받은 Pack 을 다시 UnPack 해주는 기능을 담당하고 있습니다.  
또한 데이터를 잔여 데이터가 남지 않도록 온전히 송신, 수신을 할 수 있는 기능 역시 이 클래스가 담당하고 있습니다.  
  
또한 송신을 할 때 2개 이상의 송신 Pack 이 대기중인 경우, 자칫 데이터가 꼬일 수 있기 때문에 Queue 를 사용하여 순차적으로 작업 하여 데이터 꼬임을 방지하고 있습니다.  
  
### Client
------------------------------------------------------------------  
  
Packing 클래스를 상속 받고 있으며, 클라이언트들의 정보를 관리하는 클래스입니다.  
유저, 캐릭터, 룸 등등 각 클라이언트가 가지고 있어야 될 정보들을 관리합니다.  
또한 State 패턴을 이 클래스에서 관리하게 됩니다.  
  
### State
-------------------------------------------------------------------------
  
기능을 세분화하여 관리를 더욱 쉽게 하기 위해 사용한 상태 패턴 입니다.
상태 패턴은 자동차의 기어와 같이 사용자가 사용 할 기능만 사용 할 수 있게 해줍니다.  
많은 기능을 용이하게 관리하기 위해 패턴의 특성과 프로토콜을 활용하여 설계했습니다.  
  
### Server Manager
-----------------------------------------------------------------
  
서버에 중추적인 기능을 담당하고 있는 클래스 입니다. 
Listen 소켓의 초기화, Accept 처리, 각 Client 의 송수신 처리, Client 연결 종료 시 마무리 작업 등등 서버의 메인 메커니즘을 담당하고 있습니다.  
IOCP 를 사용한 게임 서버임으로 IOCP 클래스를 상속 받습니다.  
  
### IOCP Manager
----------------------------------------------------------------------
  
이 서버는 IOCP 구조를 사용하기 때문에 IOCP Manager 클래스를 설계 하였습니다.  
Server Manager 는 IOCP Manager 를 상속 받아 사용하게 됩니다.  
만약 IOCP 가 아닌 Multi Thread, Select 등 다른 방식을 사용하는 경우 그 클래스를 설계하고 ServerManager 가 상속 받아 사용하게끔 설계하면 됩니다.  
  
### Client Manager
------------------------------------------------------------------  
  
클라이언트 정보를 관리하는 Manager 클래스 입니다.  
클라이언트를 추가, 삭제, 검색 하는 기능을 가지고 있고 클라이언트 리스트를 가지고 있습니다.  
  
  
  
### 게임 서버 구조  
--------------------------------------------------------------------------------------- 
  
![4](https://user-images.githubusercontent.com/63215359/102322067-d5045100-3fc1-11eb-8395-cfb80b29fe54.PNG)
  
  
본 프로젝트의 게임 서버에서 서버는 오로지 클라이언트에게 받은 데이터를 다른 클라이언트에게 다시 송신해주는 역할 (릴레이) 을 수행합니다.  
플레이어 캐릭터는 양측이 다 움직이기 때문에 모든 클라이언트가 다른 클라이언트에게 자신의 정보를 알리게 됩니다.  
  
하지만 몬스터는 하나의 기준으로 모든 클라이언트가 동기화가 되어야 하기 때문에 기준이 되는 클라이언트 한 명(호스트)이 다른 클라이언트에게 몬스터 정보를 알리게 됩니다.  
다만, 피격에 관해서는 예외적으로 모든 클라이언트가 서버에게 피격 정보를 주어야 하며 몬스터 피격 처리는 클라이언트가 아닌 서버에서 처리하며, 클라이언트가 피격정보를 송신하면 서버에서는 데미지와 피격 당한 몬스터의 현재 HP 를 계산 후, 계산된 HP 를 다시 모든 클라이언트에게 주어 업데이트 되도록 했습니다.  
  
본래 데디케이티드 서버로 제작하려 하였으나, 프로젝트를 진행하는데 크고 작은 예외 상황이 생겨 급조된 서버 구조입니다.  
그렇기 때문에 아쉬운 부분이 상당히 많이 보이고 특히 보안에 대한 부분을 신경쓰지 못한 점이 가장 아쉬운 거 같습니다. ( 특히 플레이어와 몬스터의 이동, 피격 부분.. )  
그래도 게임 자체는 문제 없이 구동되어 여러 사람들이 게임을 즐기며 해주었던 점에선 큰 의의를 가질 수 있었습니다.  
  
  
  
## 클라이언트 라이브러리
-----------------------------------------  
  
Unity 3D 는 C# 을 사용하고 있기 때문에 C# TCP 클라이언트 라이브러리를 설계하게 되었습니다.  
서버와 같이 TCP Socket 을 사용하였고, Protocol, Packing, Client, State 등등 클래스를 만들어 사용하였습니다.  
단, 클라이언트 서버는 IOCP 를 사용하지 않았으며, TCP/IP 구조로 설계되었습니다.  
Send,Recv 는 Queue 를 활용하여 순차적으로 진행 할 수 있게 설계하였고 각각 스레드를 생성하여 Unity 의 병렬 처리 흐름에서 분리하여 사용하였습니다.  
  
### TCP Socket
-------------------------------------------------------------------------------
  
클라이언트에서는 IOCP 를 사용하지 않고 TCP Socket 만 사용합니다.  
Connect, Send, Recv 기능을 담당하고 있으며, Pack, UnPack 을 위한 Buffer 구조체를 재정의 하였습니다.  
  
### Packing
----------------------------------------------------------------------------  
  
수신하고자 하는 데이터를 Pack 해주고, 수신 받은 데이터를 UnPack 해주는 기능을 담당하는 클래스 입니다.  
또한 송신, 수신을 위한 스레드를 생성하고 Queue 를 통해 이를 관리하게 됩니다.  
  
### Client  
----------------------------------------------------------------------------  
  
State 패턴을 사용하여 지정된 기능만 사용 할 수 있게 하는 기능을 담당하고 있습니다.  
또한 싱글톤으로 접근이 간단하고, 한 클라이언트에 한 개 이상의 Client 객체가 있는 경우를 방지하고 있습니다.  
  
### State
----------------------------------------------------------------  
  
Player, Monster, Login, Match 등 State 패턴으로 위 기능들을 관리하고 있습니다.  
State 패턴을 사용하는 기능들은 송신 시 사용 할 기능을 정의하고 수신 시 Protocol 를 분리하여 어떤 기능을 할 것인가를 결정하게 됩니다.  
TCPClient 를 상속받고 있기 때문에 접근이 간단하며 Manager 나 Control 클래스에서 송수신에 관련된 기능을 쉽게 사용할 수 있습니다.  
  
## 플레이어 동기화
-----------------------------------------
  
각 클라이언트 별로 움직이는 플레이어 캐릭터에 대한 동기화는 Other 라는 오로지 다른 클라이언트에게 받은 정보로 움직이는 오브젝트를 만들어 처리하였습니다.  
Ohter 마다 고유 번호를 가지고 있으며, 서버 또한 각 클라이언트의 고유 번호를 가지고 있어 각각의 Ohter 오브젝트가 누구의 캐릭터인 지 식별이 가능합니다.  
애니메이션 또한 플레이어 캐릭터의 Animation Controller 내에 키값을 서버에게 받아 그래도 출력해 줌으로써 동기화에 성공하였습니다.  
  
이동 시 Lerp 를 사용한 이유는 서버와 클라이언트 간 보간을 위해서 사용하였습니다.  
  
## 서버-클라이언트 보간과 보외
-----------------------------------------
  
사실 실시간 멀티 게임 서버에서 매 프레임마다 서버와 클라이언트가 패킷을 주고 받을 수 있다면 여러 기법을 필요가 없었겠지만 아쉽게도 그것은 불가능 하였습니다.  
그렇기에 선대에 많은 프로그래머 분들이 고민하고 고민하여 다양한 기법들을 만들어 왔고, 저 역시 그 기법들 중 하나를 채택하여 사용하게 되었습니다.  
  
제가 채택한 기법은 데드 레커닝 기법으로 신호가 없을 때 어떻게 처리할 것인가? 에 대한 기법이었습니다.  
만약 5 프레임마다 보내게 된다면 0~4 프레임 동안 신호를 받지 못하게 되고, 캐릭터의 움직임이 끊기게 되는 현상을 해결하고자  
저는 0 -> 5 프레임까지의 최종 위치값을 방향 벡터를 통해 예상하고 예상 위치값으로 Lerp 를 통해 이동시켜 성공적으로 보간과 보외 문제를 해결했습니다.  
  
추가로 이동이 완료되었거나, 도중 이동이 취소되는 경우 ( ex. 공격, 피격, 회피 등 ) 에는 예상 위치값이 아닌 현재 위치값을 보내줍니다.  
공격이나 회피와 같이 캐릭터 좌표가 이동되는 경우에도 데드 레커닝 기법이 적용 하였습니다.  
  
  
  
# 그 외  
-------------------------------------------  
## 맡은 역할
-------------------------------------------
  
서버와 클라이언트를 모두 담당했던 포지션으로  
서버 라이브러리 설계와 클라이언트 라이브러리 설계, 서버와 클라이언트 간 보간 작업, 플레이어 동기화 등을 맡았고,  
클라이언트 부분에서는 게임 유저 편의 시스템, 타이틀 메뉴 시스템, 캐릭터 선택 시스템 등 게임 시스템 부분을 담당 하였습니다.  
  
## 프로젝트를 진행하며 어려웠던 점
--------------------------------------------  
  
작업을 함에 있어서는 크게 어려웠던 점이 없었으나, 적지 않은 사람들과 각기 다른 분야에서 협업을 하며 게임을 제작함에 있어서 다소 어려움이 많았던 것 같았습니다.  
아직 다른 파트에서 작업을 완료하지 못하여 일정에 차질이 생기거나, 학업에도 신경을 써야 했던 점이 조금 어려웠습니다.  
개인적으로 가장 힘들었던 시기는 예상치 못한 일로 인해 제게 다른 파트의 일이 모두 맡겨졌었고, 엄청난 부담감으로 인해 힘들었던 것 같았습니다.  
  
## 개선되거나 학습한 점  
--------------------------------------------  
  
프로젝트를 하면서 혼자서는 할 수 없는 일이 같이 하면 충분히 할 수 있게 된다는 점을 일단 많이 배웠던 것 같습니다.  
막히는 부분이 있다면 서로 의견을 나누며 끝내 해결했던 과정이 제일 값졌던 것 같고, 타인과의 소통에 있어서도 많은 부분을 배웠습니다.  
특히 타협이라는 부분에서 많이 개선할 수 있었던 것 같습니다.  
  
무엇보다 제일 힘든 시기를 끝내 이겨낼 수 있었던 건 분명 옆에서 같이 고민해주던 팀원들이 있었던 덕분이라는 점을 알 수 있었습니다.  
  
